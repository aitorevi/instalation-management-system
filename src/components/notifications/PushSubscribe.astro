---
interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;

const vapidPublicKey = import.meta.env.PUBLIC_VAPID_PUBLIC_KEY;

if (!vapidPublicKey) {
  throw new Error('PUBLIC_VAPID_PUBLIC_KEY is not set in environment variables');
}
---

<div
  class={`bg-white rounded-lg shadow-sm border border-gray-200 p-6 ${className}`}
  id="push-subscribe"
>
  <div class="flex items-start justify-between gap-4">
    <div class="flex-1">
      <div class="flex items-center gap-3 mb-2">
        <div
          class="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0"
        >
          <svg
            class="w-5 h-5 text-blue-600"
            id="notification-icon"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
            ></path>
          </svg>
        </div>
        <div>
          <h3 class="text-lg font-semibold text-gray-900">Notificaciones</h3>
          <p class="text-sm text-gray-600" id="status-text">Cargando...</p>
        </div>
      </div>
      <p class="text-sm text-gray-600 mb-4">
        Recibe notificaciones instantáneas cuando se te asigne una nueva instalación.
      </p>
    </div>

    <div class="flex-shrink-0">
      <button
        type="button"
        id="notification-toggle"
        role="switch"
        aria-checked="false"
        aria-label="Activar notificaciones"
        class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 bg-gray-200"
        disabled
      >
        <span
          class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-1"
          id="toggle-indicator"></span>
      </button>
    </div>
  </div>

  <div id="alert-container" class="mt-4 hidden"></div>

  <div id="unsupported-message" class="hidden mt-4">
    <div class="flex gap-3 p-4 rounded-lg border bg-yellow-50 border-yellow-200" role="alert">
      <svg
        class="w-5 h-5 flex-shrink-0 text-yellow-800"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
        ></path>
      </svg>
      <div class="text-sm text-yellow-800">
        <p class="font-medium">Tu navegador no soporta notificaciones</p>
        <p class="mt-1">
          Para recibir notificaciones, utiliza un navegador compatible como Chrome, Firefox o
          Safari.
        </p>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ vapidPublicKey }}>
  import {
    isPushSupported,
    requestNotificationPermission,
    subscribeToPush,
    unsubscribeFromPush,
    saveSubscription,
    removeSubscription,
    getCurrentSubscription
  } from '@/lib/push';

  type UIState = 'loading' | 'unsupported' | 'disabled' | 'enabled' | 'error';

  class PushSubscribeManager {
    private state: UIState = 'loading';
    private operationInProgress: boolean = false;
    private toggleButton: HTMLButtonElement;
    private toggleIndicator: HTMLElement;
    private statusText: HTMLElement;
    private alertContainer: HTMLElement;
    private unsupportedMessage: HTMLElement;
    private notificationIcon: SVGElement;
    private vapidKey: string;

    constructor(vapidKey: string) {
      this.vapidKey = vapidKey;

      const toggle = document.getElementById('notification-toggle');
      const indicator = document.getElementById('toggle-indicator');
      const status = document.getElementById('status-text');
      const alert = document.getElementById('alert-container');
      const unsupported = document.getElementById('unsupported-message');
      const icon = document.getElementById('notification-icon');

      if (!toggle || !indicator || !status || !alert || !unsupported || !icon) {
        console.error('[PushSubscribe] Required elements not found');
        return;
      }

      this.toggleButton = toggle as HTMLButtonElement;
      this.toggleIndicator = indicator;
      this.statusText = status;
      this.alertContainer = alert;
      this.unsupportedMessage = unsupported;
      this.notificationIcon = icon as SVGElement;

      this.init();
    }

    private async init(): Promise<void> {
      if (!isPushSupported()) {
        this.updateUI('unsupported');
        return;
      }

      await this.checkSubscriptionStatus();

      this.toggleButton.addEventListener('click', () => this.handleToggle());
    }

    private async checkSubscriptionStatus(): Promise<void> {
      try {
        const subscription = await getCurrentSubscription();

        if (subscription) {
          this.updateUI('enabled');
        } else {
          this.updateUI('disabled');
        }
      } catch (error) {
        console.error('[PushSubscribe] Error checking subscription status:', error);
        this.updateUI('disabled');
      }
    }

    private async handleToggle(): Promise<void> {
      if (this.operationInProgress) {
        console.warn('[PushSubscribe] Operation already in progress, ignoring click');
        return;
      }

      const isEnabled = this.state === 'enabled';

      if (isEnabled) {
        await this.handleUnsubscribe();
      } else {
        await this.handleSubscribe();
      }
    }

    private async handleSubscribe(): Promise<void> {
      this.operationInProgress = true;
      this.updateUI('loading');
      this.hideAlert();

      try {
        const permission = await requestNotificationPermission();

        if (permission === 'denied') {
          this.showAlert(
            'error',
            'Permisos denegados',
            'No se pueden activar las notificaciones porque has denegado los permisos. Por favor, ve a la configuración de tu navegador y permite las notificaciones para este sitio.'
          );
          this.updateUI('disabled');
          return;
        }

        if (permission !== 'granted') {
          this.showAlert(
            'warning',
            'Permisos no otorgados',
            'Para recibir notificaciones, debes permitir los permisos cuando tu navegador lo solicite.'
          );
          this.updateUI('disabled');
          return;
        }

        const subscription = await subscribeToPush(this.vapidKey);

        if (!subscription) {
          this.showAlert(
            'error',
            'Error al suscribirse',
            'No se pudo crear la suscripción. Por favor, inténtalo de nuevo más tarde.',
            true
          );
          this.updateUI('disabled');
          return;
        }

        const saved = await saveSubscription(subscription);

        if (!saved) {
          await subscription.unsubscribe();
          this.showAlert(
            'error',
            'Error al guardar la suscripción',
            'No se pudo guardar la suscripción en el servidor. Verifica tu conexión e inténtalo de nuevo.',
            true
          );
          this.updateUI('disabled');
          return;
        }

        this.updateUI('enabled');
        this.showAlert(
          'success',
          'Notificaciones activadas',
          'Recibirás avisos cuando te asignen nuevas instalaciones.',
          false,
          3000
        );
      } catch (error) {
        console.error('[PushSubscribe] Error during subscription:', error);
        this.showAlert(
          'error',
          'Error inesperado',
          'Ocurrió un error al activar las notificaciones. Por favor, inténtalo de nuevo.',
          true
        );
        this.updateUI('disabled');
      } finally {
        this.operationInProgress = false;
      }
    }

    private async handleUnsubscribe(): Promise<void> {
      this.operationInProgress = true;
      this.updateUI('loading');
      this.hideAlert();

      try {
        const subscription = await getCurrentSubscription();

        if (!subscription) {
          this.updateUI('disabled');
          return;
        }

        const removed = await removeSubscription(subscription.endpoint);

        if (!removed) {
          this.showAlert(
            'error',
            'Error al desactivar',
            'No se pudo desactivar las notificaciones en el servidor. Por favor, inténtalo de nuevo.',
            true
          );
          this.updateUI('enabled');
          return;
        }

        const unsubscribed = await unsubscribeFromPush();

        if (!unsubscribed) {
          this.showAlert(
            'warning',
            'Error al desactivar',
            'Las notificaciones se desactivaron en el servidor pero hubo un problema al desactivarlas en tu navegador.',
            false
          );
        }

        this.updateUI('disabled');
        this.showAlert(
          'success',
          'Notificaciones desactivadas',
          'Ya no recibirás notificaciones de nuevas instalaciones.',
          false,
          3000
        );
      } catch (error) {
        console.error('[PushSubscribe] Error during unsubscription:', error);
        this.showAlert(
          'error',
          'Error inesperado',
          'Ocurrió un error al desactivar las notificaciones. Por favor, inténtalo de nuevo.',
          true
        );
        this.updateUI('enabled');
      } finally {
        this.operationInProgress = false;
      }
    }

    private updateUI(state: UIState): void {
      this.state = state;

      switch (state) {
        case 'loading':
          this.toggleButton.disabled = true;
          this.toggleButton.setAttribute('aria-label', 'Procesando...');
          this.statusText.textContent = 'Procesando...';
          break;

        case 'unsupported':
          this.toggleButton.disabled = true;
          this.toggleButton.classList.add('bg-gray-200');
          this.toggleButton.classList.remove('bg-green-500');
          this.toggleButton.setAttribute('aria-checked', 'false');
          this.toggleButton.setAttribute('aria-label', 'No soportado');
          this.toggleIndicator.classList.remove('translate-x-6');
          this.toggleIndicator.classList.add('translate-x-1');
          this.statusText.textContent = 'No disponible';
          this.unsupportedMessage.classList.remove('hidden');
          this.updateIcon(false);
          break;

        case 'disabled':
          this.toggleButton.disabled = false;
          this.toggleButton.classList.add('bg-gray-200');
          this.toggleButton.classList.remove('bg-green-500');
          this.toggleButton.setAttribute('aria-checked', 'false');
          this.toggleButton.setAttribute('aria-label', 'Activar notificaciones');
          this.toggleIndicator.classList.remove('translate-x-6');
          this.toggleIndicator.classList.add('translate-x-1');
          this.statusText.textContent = 'Desactivadas';
          this.statusText.classList.add('text-gray-600');
          this.statusText.classList.remove('text-green-600');
          this.updateIcon(false);
          break;

        case 'enabled':
          this.toggleButton.disabled = false;
          this.toggleButton.classList.remove('bg-gray-200');
          this.toggleButton.classList.add('bg-green-500');
          this.toggleButton.setAttribute('aria-checked', 'true');
          this.toggleButton.setAttribute('aria-label', 'Desactivar notificaciones');
          this.toggleIndicator.classList.add('translate-x-6');
          this.toggleIndicator.classList.remove('translate-x-1');
          this.statusText.textContent = 'Activadas';
          this.statusText.classList.remove('text-gray-600');
          this.statusText.classList.add('text-green-600');
          this.updateIcon(true);
          break;

        case 'error':
          this.toggleButton.disabled = false;
          this.toggleButton.classList.add('bg-gray-200');
          this.toggleButton.classList.remove('bg-green-500');
          this.toggleButton.setAttribute('aria-checked', 'false');
          this.statusText.textContent = 'Error';
          this.statusText.classList.add('text-red-600');
          this.statusText.classList.remove('text-gray-600', 'text-green-600');
          break;
      }
    }

    private updateIcon(enabled: boolean): void {
      if (enabled) {
        this.notificationIcon.innerHTML = `
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path>
        `;
      } else {
        this.notificationIcon.innerHTML = `
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6"></path>
        `;
      }
    }

    private showAlert(
      variant: 'info' | 'success' | 'warning' | 'error',
      title: string,
      message: string,
      showRetry: boolean = false,
      autoHide: number = 0
    ): void {
      const variantConfig = {
        info: {
          bg: 'bg-blue-50',
          border: 'border-blue-200',
          text: 'text-blue-800',
          icon: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>'
        },
        success: {
          bg: 'bg-green-50',
          border: 'border-green-200',
          text: 'text-green-800',
          icon: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>'
        },
        warning: {
          bg: 'bg-yellow-50',
          border: 'border-yellow-200',
          text: 'text-yellow-800',
          icon: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>'
        },
        error: {
          bg: 'bg-red-50',
          border: 'border-red-200',
          text: 'text-red-800',
          icon: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path>'
        }
      };

      const config = variantConfig[variant];

      const alertHtml = `
        <div class="flex gap-3 p-4 rounded-lg border ${config.bg} ${config.border}" role="alert">
          <svg class="w-5 h-5 flex-shrink-0 ${config.text}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            ${config.icon}
          </svg>
          <div class="flex-1 min-w-0">
            <h4 class="font-medium ${config.text}">${title}</h4>
            <p class="text-sm ${config.text} mt-1">${message}</p>
            ${
              showRetry
                ? `<button type="button" class="mt-3 text-sm font-medium ${config.text} hover:underline focus:outline-none focus:underline" onclick="document.getElementById('notification-toggle').click()">Reintentar</button>`
                : ''
            }
          </div>
          <button type="button" class="flex-shrink-0 p-1 -mr-1 rounded hover:bg-black/5 ${config.text}" onclick="this.closest('[role=alert]').remove()" aria-label="Cerrar">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
      `;

      this.alertContainer.innerHTML = alertHtml;
      this.alertContainer.classList.remove('hidden');

      if (autoHide > 0) {
        setTimeout(() => {
          this.hideAlert();
        }, autoHide);
      }
    }

    private hideAlert(): void {
      this.alertContainer.innerHTML = '';
      this.alertContainer.classList.add('hidden');
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new PushSubscribeManager(vapidPublicKey);
    });
  } else {
    new PushSubscribeManager(vapidPublicKey);
  }
</script>
